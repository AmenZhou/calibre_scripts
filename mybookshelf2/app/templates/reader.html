{% extends "base.html" %}
{% block title %}{{ ebook.title }} - Reader{% endblock %}
{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='reader.css') }}">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.88/dist/epub.min.js"></script>
{% endblock %}
{% block content %}
<div class="reader-container">
    <div class="reader-header">
        <div class="reader-nav-left">
            <a href="{{ url_for('minimal.ebook_detail', id=ebook.id) }}" class="btn btn-black btn-sm">← Back</a>
            <button id="toc-toggle" class="btn btn-black btn-sm">Contents</button>
        </div>
        <div class="reader-title">
            <h2>{{ ebook.title }}</h2>
            <div class="reader-meta">
                {% for author in ebook.authors %}
                    <span>{{ author.first_name }} {{ author.last_name }}</span>
                    {% if not loop.last %}, {% endif %}
                {% endfor %}
            </div>
        </div>
        <div class="reader-nav-right">
            <button id="settings-toggle" class="btn btn-black btn-sm">Settings</button>
            <span id="reader-progress">0%</span>
        </div>
    </div>

    <div class="reader-main">
        <div id="sidebar" class="sidebar hidden">
            <div class="sidebar-header">
                <h3>Table of Contents</h3>
                <button id="toc-close" class="btn btn-sm">×</button>
            </div>
            <nav id="toc" class="toc"></nav>
        </div>

        <div id="book-container" class="book-container"></div>

        <div id="settings-panel" class="settings-panel hidden">
            <div class="settings-header">
                <h3>Reader Settings</h3>
                <button id="settings-close" class="btn btn-sm">×</button>
            </div>
            <div class="settings-content">
                <div class="setting-item">
                    <label for="font-size">Font Size:</label>
                    <input type="range" id="font-size" min="75" max="200" value="100">
                    <span id="font-size-value">100%</span>
                </div>
                <div class="setting-item">
                    <label for="theme">Theme:</label>
                    <select id="theme">
                        <option value="default">Default</option>
                        <option value="night">Night</option>
                        <option value="sepia">Sepia</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="font-family">Font:</label>
                    <select id="font-family">
                        <option value="Georgia">Georgia</option>
                        <option value="Palatino">Palatino</option>
                        <option value="Times">Times</option>
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="reader-controls">
        <button id="prev" class="btn btn-black">← Previous</button>
        <div class="reader-info">
            <span id="current-location">Loading...</span>
        </div>
        <button id="next" class="btn btn-black">Next →</button>
    </div>
</div>

<script>
(function() {
    const sourceId = {{ source.id }};
    {% if is_converted %}
    const bookUrl = "{{ url_for('api.read_converted', id=conversion_id) }}";
    const conversionId = {{ conversion_id }};
    // Store conversion ID in a way EPUB.js can access it
    window.epubConversionId = {{ conversion_id }};
    {% else %}
    const bookUrl = "{{ url_for('api.read', id=source.id) }}";
    {% endif %}
    const format = "{{ source.format.extension.lower() if source.format else '' }}";
    
    let book, rendition;
    let currentLocation = null;

    // Initialize book
    if (format === 'epub') {
        // Configure EPUB.js to use the book URL as archive
        // EPUB.js will handle extracting and loading internal files
        // For EPUB.js 0.3.88, we need to configure the archive URL resolver
        // so it can access internal EPUB files correctly
        {% if is_converted %}
        // For converted files, EPUB.js needs to access internal files
        // The issue is EPUB.js constructs URLs like "/api/read-converted/META-INF/container.xml"
        // but we need "/api/read-converted/3/META-INF/container.xml"
        // We'll use EPUB.js's requestMethod to handle all requests
        const baseUrl = "{{ url_for('api.read_converted', id=conversion_id) }}";
        const conversionId = {{ conversion_id }};
        const correctBaseUrl = "{{ url_for('api.read_converted_file', id=conversion_id, file_path='') }}";
        
        // Custom request method for EPUB.js that rewrites URLs
        function customRequestMethod(url, options) {
            // Handle both absolute and relative URLs
            let finalUrl = url;
            
            // If it's a relative URL (starts with a path, not http/https)
            if (url && !url.match(/^https?:\/\//) && !url.match(/^\/api\/read-converted\/\d+\//)) {
                // It's a relative path, prepend the base URL
                if (url.startsWith('/')) {
                    // Absolute path like "/api/read-converted/stylesheet.css"
                    const match = url.match(/^\/api\/read-converted\/(.+)$/);
                    if (match) {
                        finalUrl = correctBaseUrl + match[1];
                    } else {
                        // Other absolute paths - might be from HTML content
                        finalUrl = correctBaseUrl + url.substring(1);
                    }
                } else {
                    // Relative path like "stylesheet.css" or "cover1.jpg"
                    finalUrl = correctBaseUrl + url;
                }
            } else if (url && url.includes('/api/read-converted/') && !url.match(/\/api\/read-converted\/\d+\//)) {
                // URL is like "/api/read-converted/META-INF/container.xml"
                const match = url.match(/\/api\/read-converted\/(.+)$/);
                if (match) {
                    finalUrl = correctBaseUrl + match[1];
                }
            }
            
            // Use fetch to make the request
            console.log('Converted EPUB request:', url, '->', finalUrl);
            
            // Check if this is a binary request
            const isBinary = options === "binary" || options === "blob" || (options && (options.binary || options.blob));
            if (isBinary) {
                console.log('Binary request detected for converted EPUB, will convert to blob');
            }
            
            // Ensure options is an object for fetch
            const fetchOptions = (typeof options === 'object' && options !== null) ? { ...options } : {};
            
            return fetch(finalUrl, fetchOptions).then(function(response) {
                if (!response.ok && response.status !== 206) {  // 206 is Partial Content, which is OK
                    console.error('Request failed:', finalUrl, response.status, response.statusText);
                    throw new Error('HTTP error! status: ' + response.status);
                }
                
                // For binary requests, convert response to blob
                if (isBinary) {
                    console.log('Converting converted EPUB response to blob for binary request');
                    return response.blob().then(function(blob) {
                        console.log('Blob created for converted EPUB, size:', blob.size);
                        return blob;
                    });
                }
                
                // For non-binary requests, return Response object as-is
                return response;
            }).catch(function(error) {
                console.error('Fetch error for converted EPUB:', finalUrl, error);
                throw error;
            });
        }
        
        // Also intercept global fetch and XHR for any requests that bypass requestMethod
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
            if (typeof url === 'string') {
                // Rewrite URLs that need conversion ID
                if (url.includes('/api/read-converted/') && !url.match(/\/api\/read-converted\/\d+\//)) {
                    const match = url.match(/\/api\/read-converted\/(.+)$/);
                    if (match) {
                        url = correctBaseUrl + match[1];
                    }
                } else if (url && !url.match(/^https?:\/\//) && !url.match(/^\/api\/read-converted\/\d+\//)) {
                    // Relative URL - might be from HTML content
                    if (url.startsWith('/')) {
                        const match = url.match(/^\/api\/read-converted\/(.+)$/);
                        if (match) {
                            url = correctBaseUrl + match[1];
                        }
                    } else {
                        // Pure relative path
                        url = correctBaseUrl + url;
                    }
                }
            }
            return originalFetch.apply(this, arguments);
        };
        
        const originalXHROpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
            if (typeof url === 'string') {
                if (url.includes('/api/read-converted/') && !url.match(/\/api\/read-converted\/\d+\//)) {
                    const match = url.match(/\/api\/read-converted\/(.+)$/);
                    if (match) {
                        url = correctBaseUrl + match[1];
                    }
                } else if (url && !url.match(/^https?:\/\//) && !url.match(/^\/api\/read-converted\/\d+\//)) {
                    // Relative URL
                    if (url.startsWith('/')) {
                        const match = url.match(/^\/api\/read-converted\/(.+)$/);
                        if (match) {
                            url = correctBaseUrl + match[1];
                        }
                    } else {
                        url = correctBaseUrl + url;
                    }
                }
            }
            return originalXHROpen.apply(this, arguments);
        };
        
        book = ePub(baseUrl, {
            requestMethod: customRequestMethod
        });
        {% else %}
        // For regular source EPUB files, we also need URL rewriting
        // EPUB.js constructs URLs like "/api/read/META-INF/container.xml"
        // but we need "/api/read/<source_id>/META-INF/container.xml"
        const sourceId = {{ source.id }};
        const sourceBaseUrl = "{{ url_for('api.read', id=source.id) }}";
        const sourceCorrectBaseUrl = "{{ url_for('api.read_file', id=source.id, file_path='') }}";
        const bookUrl = sourceBaseUrl; // For source files, bookUrl is the same as sourceBaseUrl
        
        // Custom request method for source EPUB files
        function sourceRequestMethod(url, options) {
            let finalUrl = url;
            
            // Check if this is a binary request (check early, used in multiple places)
            const isBinary = options === "binary" || options === "blob" || (options && (options.binary || options.blob));
            
            console.log('sourceRequestMethod called with URL:', url);
            console.log('sourceRequestMethod options:', options);
            if (isBinary) {
                console.log('Binary request detected');
            }
            
            // Extract the path from full URLs (http://domain/path) or use as-is for relative paths
            let urlPath = url;
            if (url.match(/^https?:\/\//)) {
                // Full URL - extract the path
                try {
                    const urlObj = new URL(url);
                    urlPath = urlObj.pathname + (urlObj.search || '');
                } catch (e) {
                    // If URL parsing fails, try to extract path manually
                    const match = url.match(/https?:\/\/[^\/]+(\/.*)$/);
                    if (match) {
                        urlPath = match[1];
                    }
                }
            }
            
            // Don't rewrite the main book URL itself - this is critical for initial load
            // Check both with and without leading slash, and with/without protocol
            const normalizedSourceBase = sourceBaseUrl.replace(/^https?:\/\/[^\/]+/, '');
            const normalizedBookUrl = bookUrl.replace(/^https?:\/\/[^\/]+/, '');
            
            if (urlPath === sourceBaseUrl || urlPath === bookUrl || 
                urlPath === sourceBaseUrl + '/' || urlPath === bookUrl + '/' ||
                urlPath === normalizedSourceBase || urlPath === normalizedBookUrl ||
                urlPath === normalizedSourceBase + '/' || urlPath === normalizedBookUrl + '/') {
                console.log('Skipping rewrite for main book URL:', url);
                // Ensure we use the correct URL format
                const fetchUrl = url.match(/^https?:\/\//) ? url : (window.location.origin + (url.startsWith('/') ? url : '/' + url));
                
                // Handle binary requests for main book URL
                if (isBinary) {
                    console.log('Binary request detected for main book URL, will convert to blob');
                    const fetchOptions = (typeof options === 'object' && options !== null) ? { ...options } : {};
                    return fetch(fetchUrl, fetchOptions).then(function(response) {
                        if (!response.ok && response.status !== 206) {
                            console.error('Request failed:', fetchUrl, response.status, response.statusText);
                            throw new Error('HTTP error! status: ' + response.status);
                        }
                        console.log('Request successful (main book URL):', fetchUrl, 'Status:', response.status);
                        console.log('Converting main book URL response to blob');
                        return response.blob().then(function(blob) {
                            console.log('Blob created for main book URL, size:', blob.size);
                            return blob;
                        });
                    });
                }
                
                return fetch(fetchUrl, options || {});
            }
            
            // Also check if it's the exact book URL pattern (without query params)
            const urlPathWithoutQuery = urlPath.split('?')[0];
            if (urlPathWithoutQuery === sourceBaseUrl || urlPathWithoutQuery === bookUrl ||
                urlPathWithoutQuery === normalizedSourceBase || urlPathWithoutQuery === normalizedBookUrl) {
                console.log('Skipping rewrite for main book URL (without query):', url);
                const fetchUrl = url.match(/^https?:\/\//) ? url : (window.location.origin + (url.startsWith('/') ? url : '/' + url));
                
                // Handle binary requests for main book URL (without query)
                if (isBinary) {
                    console.log('Binary request detected for main book URL (no query), will convert to blob');
                    const fetchOptions = (typeof options === 'object' && options !== null) ? { ...options } : {};
                    return fetch(fetchUrl, fetchOptions).then(function(response) {
                        if (!response.ok && response.status !== 206) {
                            console.error('Request failed:', fetchUrl, response.status, response.statusText);
                            throw new Error('HTTP error! status: ' + response.status);
                        }
                        console.log('Request successful (main book URL, no query):', fetchUrl, 'Status:', response.status);
                        console.log('Converting main book URL response to blob');
                        return response.blob().then(function(blob) {
                            console.log('Blob created for main book URL, size:', blob.size);
                            return blob;
                        });
                    });
                }
                
                return fetch(fetchUrl, options || {});
            }
            
            // Check if this is an internal EPUB file that needs the source ID
            // Pattern: /api/read/... where ... is NOT a number (source ID)
            if (urlPath.includes('/api/read/') && !urlPath.match(/^\/api\/read\/\d+(\/|$|\?)/)) {
                // Extract the file path after /api/read/
                const match = urlPath.match(/\/api\/read\/(.+)$/);
                if (match) {
                    // Reconstruct with source ID
                    finalUrl = sourceCorrectBaseUrl + match[1];
                    // If original was a full URL, reconstruct as full URL
                    if (url.match(/^https?:\/\//)) {
                        const urlObj = new URL(url);
                        finalUrl = urlObj.origin + finalUrl;
                    }
                    console.log('Rewriting URL:', url, '->', finalUrl);
                }
            } else if (urlPath && !urlPath.match(/^https?:\/\//) && !urlPath.match(/^\/api\/read\/\d+(\/|$)/)) {
                // Relative URL that's not the main book URL
                if (urlPath.startsWith('/')) {
                    // Absolute path like "/api/read/stylesheet.css"
                    const match = urlPath.match(/^\/api\/read\/(.+)$/);
                    if (match) {
                        finalUrl = sourceCorrectBaseUrl + match[1];
                        // If original was a full URL, reconstruct as full URL
                        if (url.match(/^https?:\/\//)) {
                            const urlObj = new URL(url);
                            finalUrl = urlObj.origin + finalUrl;
                        }
                    } else {
                        // Other absolute paths - might be from HTML content
                        finalUrl = sourceCorrectBaseUrl + urlPath.substring(1);
                        if (url.match(/^https?:\/\//)) {
                            const urlObj = new URL(url);
                            finalUrl = urlObj.origin + finalUrl;
                        }
                    }
                } else {
                    // Relative path like "stylesheet.css" or "cover1.jpg"
                    finalUrl = sourceCorrectBaseUrl + urlPath;
                    if (url.match(/^https?:\/\//)) {
                        const urlObj = new URL(url);
                        finalUrl = urlObj.origin + finalUrl;
                    }
                }
                console.log('Rewriting relative URL:', url, '->', finalUrl);
            }
            
            // Use fetch to make the request
            console.log('Making request to:', finalUrl);
            
            if (isBinary) {
                console.log('Binary request detected for internal file, will convert to blob');
            }
            
            // Ensure options has proper headers for Range requests
            const fetchOptions = (typeof options === 'object' && options !== null) ? { ...options } : {};
            if (!fetchOptions.headers) {
                fetchOptions.headers = {};
            }
            // Preserve Range header if present
            if (options && typeof options === 'object' && options.headers && options.headers.Range) {
                fetchOptions.headers.Range = options.headers.Range;
            }
            
            return fetch(finalUrl, fetchOptions).then(function(response) {
                if (!response.ok && response.status !== 206) {  // 206 is Partial Content, which is OK
                    console.error('Request failed:', finalUrl, response.status, response.statusText);
                    throw new Error('HTTP error! status: ' + response.status);
                }
                console.log('Request successful:', finalUrl, 'Status:', response.status);
                
                // For binary requests, convert response to blob
                if (isBinary) {
                    console.log('Converting response to blob for binary request');
                    return response.blob().then(function(blob) {
                        console.log('Blob created, size:', blob.size);
                        return blob;
                    });
                }
                
                // For non-binary requests, return Response object as-is
                // Ensure response is readable
                if (!response.body) {
                    console.error('Response has no body:', finalUrl);
                }
                return response;
            }).catch(function(error) {
                console.error('Fetch error:', finalUrl, error);
                throw error;
            });
        }
        
        // Also intercept global fetch and XHR for source EPUB files
        // Store the original book URL to exclude it from rewriting
        const originalBookUrl = sourceBaseUrl;
        const originalFetch = window.fetch;
        window.fetch = function(url, options) {
            if (typeof url === 'string') {
                // Don't rewrite if URL already has the source ID (already been rewritten)
                // Pattern: /api/read/\d+/... (source ID followed by a path)
                if (url.match(/\/api\/read\/\d+\//)) {
                    // Already has source ID, don't rewrite
                    return originalFetch.apply(this, arguments);
                }
                
                // Don't rewrite the main book URL itself
                if (url === originalBookUrl || url === sourceBaseUrl) {
                    return originalFetch.apply(this, arguments);
                }
                
                // Extract path from full URLs
                let urlPath = url;
                if (url.match(/^https?:\/\//)) {
                    try {
                        const urlObj = new URL(url);
                        urlPath = urlObj.pathname + (urlObj.search || '');
                    } catch (e) {
                        const match = url.match(/https?:\/\/[^\/]+(\/.*)$/);
                        if (match) {
                            urlPath = match[1];
                        }
                    }
                }
                
                // Rewrite URLs that need source ID (internal EPUB files)
                // Exclude the main book URL: /api/read/\d+ (exact match or with trailing slash)
                if (urlPath.includes('/api/read/') && !urlPath.match(/^\/api\/read\/\d+(\/|$|\?)/)) {
                    const match = urlPath.match(/\/api\/read\/(.+)$/);
                    if (match) {
                        const newPath = sourceCorrectBaseUrl + match[1];
                        // If original was a full URL, reconstruct as full URL
                        if (url.match(/^https?:\/\//)) {
                            const urlObj = new URL(url);
                            url = urlObj.origin + newPath;
                        } else {
                            url = newPath;
                        }
                    }
                } else if (urlPath && !urlPath.match(/^https?:\/\//) && !urlPath.match(/^\/api\/read\/\d+(\/|$)/)) {
                    // Relative URL - might be from HTML content
                    if (urlPath.startsWith('/')) {
                        const match = urlPath.match(/^\/api\/read\/(.+)$/);
                        if (match) {
                            const newPath = sourceCorrectBaseUrl + match[1];
                            if (url.match(/^https?:\/\//)) {
                                const urlObj = new URL(url);
                                url = urlObj.origin + newPath;
                            } else {
                                url = newPath;
                            }
                        }
                    } else {
                        // Pure relative path (but not the base URL)
                        if (urlPath !== originalBookUrl && urlPath !== sourceBaseUrl) {
                            const newPath = sourceCorrectBaseUrl + urlPath;
                            if (url.match(/^https?:\/\//)) {
                                const urlObj = new URL(url);
                                url = urlObj.origin + newPath;
                            } else {
                                url = newPath;
                            }
                        }
                    }
                }
            }
            return originalFetch.apply(this, arguments);
        };
        
        const originalXHROpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
            if (typeof url === 'string') {
                // Don't rewrite if URL already has the source ID (already been rewritten)
                if (url.match(/\/api\/read\/\d+\//)) {
                    // Already has source ID, don't rewrite
                    return originalXHROpen.apply(this, arguments);
                }
                
                // Don't rewrite the main book URL itself
                if (url === originalBookUrl || url === sourceBaseUrl) {
                    return originalXHROpen.apply(this, arguments);
                }
                
                // Extract path from full URLs
                let urlPath = url;
                if (url.match(/^https?:\/\//)) {
                    try {
                        const urlObj = new URL(url);
                        urlPath = urlObj.pathname + (urlObj.search || '');
                    } catch (e) {
                        const match = url.match(/https?:\/\/[^\/]+(\/.*)$/);
                        if (match) {
                            urlPath = match[1];
                        }
                    }
                }
                
                // Exclude the main book URL: /api/read/\d+ (exact match or with trailing slash)
                if (urlPath.includes('/api/read/') && !urlPath.match(/^\/api\/read\/\d+(\/|$|\?)/)) {
                    const match = urlPath.match(/\/api\/read\/(.+)$/);
                    if (match) {
                        const newPath = sourceCorrectBaseUrl + match[1];
                        // If original was a full URL, reconstruct as full URL
                        if (url.match(/^https?:\/\//)) {
                            const urlObj = new URL(url);
                            url = urlObj.origin + newPath;
                        } else {
                            url = newPath;
                        }
                    }
                } else if (urlPath && !urlPath.match(/^https?:\/\//) && !urlPath.match(/^\/api\/read\/\d+(\/|$)/)) {
                    // Relative URL
                    if (urlPath.startsWith('/')) {
                        const match = urlPath.match(/^\/api\/read\/(.+)$/);
                        if (match) {
                            const newPath = sourceCorrectBaseUrl + match[1];
                            if (url.match(/^https?:\/\//)) {
                                const urlObj = new URL(url);
                                url = urlObj.origin + newPath;
                            } else {
                                url = newPath;
                            }
                        }
                    } else {
                        // Pure relative path (but not the base URL)
                        if (urlPath !== originalBookUrl && urlPath !== sourceBaseUrl) {
                            const newPath = sourceCorrectBaseUrl + urlPath;
                            if (url.match(/^https?:\/\//)) {
                                const urlObj = new URL(url);
                                url = urlObj.origin + newPath;
                            } else {
                                url = newPath;
                            }
                        }
                    }
                }
            }
            return originalXHROpen.apply(this, arguments);
        };
        
        // Ensure sourceBaseUrl is a full URL for EPUB.js
        const fullSourceBaseUrl = sourceBaseUrl.startsWith('http') ? sourceBaseUrl : (window.location.origin + (sourceBaseUrl.startsWith('/') ? sourceBaseUrl : '/' + sourceBaseUrl));
        console.log('Creating EPUB.js book with URL:', fullSourceBaseUrl);
        
        book = ePub(fullSourceBaseUrl, {
            requestMethod: sourceRequestMethod,
            openAs: 'epub'
        });
        
        console.log('EPUB.js book object created');
        console.log('Book URL:', fullSourceBaseUrl);
        console.log('Book requestMethod:', typeof sourceRequestMethod);
        {% endif %}
        
        // bookUrl is already defined above for source files, or we need to define it for converted files
        {% if not is_converted %}
        // bookUrl already defined above for source files
        {% else %}
        const bookUrl = '{{ url_for("api.read_converted", id=conversion_id) }}';
        {% endif %}
        console.log('Initializing EPUB.js with URL:', bookUrl);
        
        // Ensure book-container is visible and has proper dimensions
        const container = document.getElementById('book-container');
        if (container) {
            container.style.minHeight = '600px';
            container.style.width = '100%';
            console.log('Container dimensions:', container.offsetWidth, 'x', container.offsetHeight);
        } else {
            console.error('book-container element not found!');
        }
        
        rendition = book.renderTo("book-container", {
            width: "100%",
            height: "100%",
            spread: "none"
        });

        if (!rendition) {
            console.error('Failed to create rendition');
            document.getElementById('book-container').innerHTML = 
                '<div class="error-message">Failed to initialize book reader. Please try refreshing the page.</div>';
        } else {
            console.log('Rendition created successfully');
        }

        // Test if book URL is accessible first
        console.log('Testing book URL accessibility:', bookUrl);
        const fullBookUrl = bookUrl.startsWith('http') ? bookUrl : (window.location.origin + bookUrl);
        console.log('Full book URL:', fullBookUrl);
        
        fetch(fullBookUrl, { method: 'HEAD' })
            .then(function(response) {
                console.log('Book URL test response:', response.status, response.statusText);
                console.log('Content-Type:', response.headers.get('Content-Type'));
                console.log('Content-Length:', response.headers.get('Content-Length'));
                console.log('Accept-Ranges:', response.headers.get('Accept-Ranges'));
                if (!response.ok) {
                    console.error('Book URL not accessible:', response.status);
                    document.getElementById('book-container').innerHTML = 
                        '<div class="error-message">Cannot access book file (HTTP ' + response.status + '). Please check if the file exists.</div>';
                } else {
                    // Test with a Range request to ensure Range support works
                    fetch(fullBookUrl, { 
                        method: 'GET',
                        headers: { 'Range': 'bytes=0-1023' }
                    }).then(function(rangeResponse) {
                        console.log('Range request test:', rangeResponse.status, rangeResponse.statusText);
                        if (rangeResponse.status === 206) {
                            console.log('Range requests are supported');
                        } else {
                            console.warn('Range requests may not be supported (got status', rangeResponse.status, ')');
                        }
                    }).catch(function(err) {
                        console.error('Range request test failed:', err);
                    });
                }
            })
            .catch(function(error) {
                console.error('Error testing book URL:', error);
            });

        // Add error handlers before book.ready
        console.log('Setting up book.opened handler...');
        
        // Listen for book opening events
        if (book.on) {
            book.on('opened', function() {
                console.log('Book opened event fired');
            });
            
            book.on('failed', function(err) {
                console.error('Book failed event:', err);
            });
        }
        
        book.opened.then(function() {
            console.log('Book opened successfully');
            console.log('Book spine:', book.spine ? 'exists' : 'missing');
            console.log('Book navigation:', book.navigation ? 'exists' : 'missing');
            if (book.spine) {
                console.log('Book spine length:', book.spine.length);
            }
        }).catch(function(err) {
            console.error('Error opening book:', err);
            console.error('Error details:', err.message, err.stack);
            console.error('Error name:', err.name);
            console.error('Full error object:', err);
            document.getElementById('book-container').innerHTML = 
                '<div class="error-message">Error opening book: ' + (err.message || 'Unknown error') + '<br>Check console for details.</div>';
        });

        console.log('Setting up book.ready handler...');
        // Add a timeout to see if ready never resolves
        const readyTimeout = setTimeout(function() {
            console.warn('book.ready has not resolved after 5 seconds');
            console.log('Checking book state...');
            console.log('book.isOpen:', book.isOpen);
            console.log('book.isReady:', book.isReady);
            console.log('book.loaded:', book.loaded ? 'exists' : 'missing');
        }, 5000);
        
        book.ready.then(function() {
            clearTimeout(readyTimeout);
            console.log('Book ready promise resolved');
            console.log('Book ready, displaying...');
            if (!rendition) {
                console.error('Rendition not initialized');
                document.getElementById('book-container').innerHTML = 
                    '<div class="error-message">Failed to initialize book reader. Please try refreshing the page.</div>';
                return;
            }
            
            // Check container before displaying
            const container = document.getElementById('book-container');
            console.log('Container before display:', container ? 'found' : 'not found');
            if (container) {
                console.log('Container innerHTML length:', container.innerHTML.length);
                console.log('Container children:', container.children.length);
            }
            
            // Wait a bit for the container to be ready
            setTimeout(function() {
                try {
                    console.log('Calling rendition.display()...');
                    console.log('Rendition state before display:', {
                        manager: rendition.manager ? 'exists' : 'missing',
                        book: rendition.book ? 'exists' : 'missing'
                    });
                    
                    const displayPromise = rendition.display();
                    console.log('display() returned:', displayPromise ? 'promise' : 'undefined/null');
                    
                    if (displayPromise && displayPromise.then) {
                        displayPromise.then(function() {
                            console.log('Book displayed successfully');
                            // Check container after display
                            setTimeout(function() {
                                const containerAfter = document.getElementById('book-container');
                                if (containerAfter) {
                                    console.log('Container after display - innerHTML length:', containerAfter.innerHTML.length);
                                    console.log('Container after display - children:', containerAfter.children.length);
                                    console.log('Container HTML:', containerAfter.innerHTML.substring(0, 200));
                                    // Check for iframe
                                    const iframe = containerAfter.querySelector('iframe');
                                    console.log('Iframe found:', iframe ? 'yes' : 'no');
                                    if (iframe) {
                                        console.log('Iframe src:', iframe.src);
                                        console.log('Iframe dimensions:', iframe.offsetWidth, 'x', iframe.offsetHeight);
                                    }
                                    // Check for EPUB.js elements
                                    const epubElements = containerAfter.querySelectorAll('div, iframe, svg');
                                    console.log('EPUB.js elements found:', epubElements.length);
                                }
                            }, 500);
                            // Update location text
                            const locationElement = document.getElementById('current-location');
                            if (locationElement) {
                                locationElement.textContent = 'Page 1';
                            }
                        }).catch(function(err) {
                            console.error('Error displaying book:', err);
                            console.error('Error stack:', err.stack);
                            document.getElementById('book-container').innerHTML = 
                                '<div class="error-message">Error displaying book: ' + (err.message || 'Unknown error') + '<br>Check console for details.</div>';
                        });
                    } else {
                        console.log('Display called (no promise returned)');
                        // Check container even if no promise
                        setTimeout(function() {
                            const containerAfter = document.getElementById('book-container');
                            if (containerAfter) {
                                console.log('Container after display (no promise) - innerHTML length:', containerAfter.innerHTML.length);
                                console.log('Container after display (no promise) - children:', containerAfter.children.length);
                                console.log('Container HTML:', containerAfter.innerHTML.substring(0, 200));
                            }
                        }, 1000);
                    }
                } catch (err) {
                    console.error('Exception during display:', err);
                    console.error('Exception stack:', err.stack);
                    document.getElementById('book-container').innerHTML = 
                        '<div class="error-message">Exception during display: ' + (err.message || 'Unknown error') + '<br>Check console for details.</div>';
                }
            }, 200);
            
            setupTOC();
            updateProgress();
            
            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (e.key === 'ArrowLeft') {
                    prevPage();
                } else if (e.key === 'ArrowRight') {
                    nextPage();
                }
            });
        }).catch(function(error) {
            console.error('Error in book.ready promise:', error);
            console.error('Error stack:', error.stack);
            document.getElementById('book-container').innerHTML = 
                '<div class="error-message">' +
                '<h3>Error Loading Book</h3>' +
                '<p>Could not load the EPUB file. Please try again or download the file instead.</p>' +
                '<p>Error: ' + (error.message || 'Unknown error') + '</p>' +
                '<p>Check the browser console for more details.</p>' +
                '</div>';
        });

        // Add a timeout to detect if book.ready never resolves
        setTimeout(function() {
            if (!book.isOpen) {
                console.warn('Book.ready has not resolved after 10 seconds. Book may not be opening.');
                console.log('Book state:', {
                    isOpen: book.isOpen,
                    isReady: book.isReady,
                    spine: book.spine ? 'exists' : 'missing'
                });
            }
        }, 10000);

        if (rendition) {
            rendition.on('relocated', function(location) {
                currentLocation = location;
                updateLocation();
                updateProgress();
            });
            
            rendition.on('displayed', function() {
                console.log('Page displayed');
            });
            
            rendition.on('rendered', function() {
                console.log('Page rendered');
            });
        }
    } else if (format === 'fb2') {
        // FB2 files need to be converted to EPUB for reading
        const ebookId = {{ ebook.id }};
        const sourceId = {{ source.id }};
        document.getElementById('book-container').innerHTML = 
            '<div class="error-message">' +
            '<h3>FB2 Format Not Directly Supported</h3>' +
            '<p>Please convert this FB2 file to EPUB format to read it in the browser.</p>' +
            '<p><strong>Quick Convert:</strong> Click the button below to convert this FB2 file to EPUB automatically.</p>' +
            '<form id="convert-form" action="{{ url_for("minimal.convert_source", id=ebook.id) }}" method="POST" style="display: inline;">' +
            '<input type="hidden" name="source_id" value="' + sourceId + '">' +
            '<input type="hidden" name="format" value="epub">' +
            '<button type="submit" class="btn btn-black">Convert to EPUB</button>' +
            '</form>' +
            '<p style="margin-top: 10px;"><a href="{{ url_for("minimal.ebook_detail", id=ebook.id) }}" class="btn btn-black btn-sm">Go Back to Book Page</a></p>' +
            '</div>';
    } else {
        document.getElementById('book-container').innerHTML = 
            '<div class="error-message">This format (' + format + ') is not supported for reading. Please download the file instead.</div>';
    }

    function setupTOC() {
        book.loaded.navigation.then(function(nav) {
            const tocElement = document.getElementById('toc');
            tocElement.innerHTML = '';
            
            function buildTOC(items) {
                const list = document.createElement('ul');
                list.className = 'toc-list';
                items.forEach(function(item) {
                    const listItem = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = item.href;
                    link.textContent = item.label;
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        rendition.display(item.href);
                        document.getElementById('sidebar').classList.add('hidden');
                    });
                    listItem.appendChild(link);
                    if (item.subitems && item.subitems.length > 0) {
                        listItem.appendChild(buildTOC(item.subitems));
                    }
                    list.appendChild(listItem);
                });
                return list;
            }

            if (nav && nav.toc) {
                tocElement.appendChild(buildTOC(nav.toc));
            }
        });
    }

    function updateLocation() {
        if (currentLocation) {
            const locationElement = document.getElementById('current-location');
            if (locationElement) {
                const start = currentLocation.start;
                if (start) {
                    locationElement.textContent = `Page ${start.displayed.page || 'N/A'}`;
                }
            }
        }
    }

    function updateProgress() {
        if (book && currentLocation) {
            book.locations.generate(2000).then(function(locations) {
                let percentage = 0;
                if (currentLocation.start && currentLocation.start.cfi) {
                    // Try different methods depending on EPUB.js version
                    if (locations.percentageFromCfi) {
                        percentage = locations.percentageFromCfi(currentLocation.start.cfi);
                    } else if (locations.percentageFromLocation) {
                        percentage = locations.percentageFromLocation(currentLocation.start);
                    } else if (locations.locationFromCfi) {
                        // Fallback: estimate based on location
                        const loc = locations.locationFromCfi(currentLocation.start.cfi);
                        if (loc && loc.total) {
                            percentage = loc.displayed.page / loc.total;
                        }
                    }
                }
                const progressElement = document.getElementById('reader-progress');
                if (progressElement) {
                    progressElement.textContent = Math.floor(percentage * 100) + '%';
                }
            }).catch(function(error) {
                console.warn('Could not calculate progress:', error);
                // Don't show error to user, just leave progress as is
            });
        }
    }

    function prevPage() {
        if (rendition && rendition.prev) {
            try {
                rendition.prev();
            } catch (e) {
                console.error('Error navigating to previous page:', e);
            }
        } else {
            console.warn('Rendition not ready for navigation');
        }
    }

    function nextPage() {
        if (rendition && rendition.next) {
            try {
                rendition.next();
            } catch (e) {
                console.error('Error navigating to next page:', e);
            }
        } else {
            console.warn('Rendition not ready for navigation');
        }
    }

    function applySettings() {
        if (!rendition) return;
        
        const fontSize = document.getElementById('font-size').value;
        const theme = document.getElementById('theme').value;
        const fontFamily = document.getElementById('font-family').value;
        
        rendition.themes.default({
            'body': {
                'font-size': fontSize + '%',
                'font-family': fontFamily
            }
        });
        
        if (theme === 'night') {
            rendition.themes.register('night', {
                'body': {
                    'background': '#1a1a1a !important',
                    'color': '#fff !important'
                }
            });
            rendition.themes.select('night');
        } else if (theme === 'sepia') {
            rendition.themes.register('sepia', {
                'body': {
                    'background': '#f4ecd8 !important',
                    'color': '#5b4636 !important'
                }
            });
            rendition.themes.select('sepia');
        } else {
            rendition.themes.select('default');
        }
    }

    // Event listeners
    document.getElementById('prev').addEventListener('click', prevPage);
    document.getElementById('next').addEventListener('click', nextPage);
    
    document.getElementById('toc-toggle').addEventListener('click', function() {
        document.getElementById('sidebar').classList.toggle('hidden');
    });
    
    document.getElementById('toc-close').addEventListener('click', function() {
        document.getElementById('sidebar').classList.add('hidden');
    });
    
    document.getElementById('settings-toggle').addEventListener('click', function() {
        document.getElementById('settings-panel').classList.toggle('hidden');
    });
    
    document.getElementById('settings-close').addEventListener('click', function() {
        document.getElementById('settings-panel').classList.add('hidden');
    });

    document.getElementById('font-size').addEventListener('input', function(e) {
        document.getElementById('font-size-value').textContent = e.target.value + '%';
        applySettings();
    });

    document.getElementById('theme').addEventListener('change', applySettings);
    document.getElementById('font-family').addEventListener('change', applySettings);
})();
</script>
{% endblock %}

